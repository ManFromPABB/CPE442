In our implementation, we chose to use four worker threads along with a synchronization thread in order to divide the sobel workload. Each worker thread is assigned a set of rows that it must compute the sobel filter for. The thread will block once it has finished its own chunk while waiting for the other workers to finish. Once the barrieris passed, control is handed back to the synchronization thread to display the current frame and grab the next one to assign it back to the workers. Our implementation prioritizes efficient L2 cache utilization since the data can be read into shared memory that all the threads can access simultaneously and efficiently.
